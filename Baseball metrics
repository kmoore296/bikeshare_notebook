
# coding: utf-8

# In[1]:


import pandas as pd
import numpy as np
#import datetime
#from dateutil import parser
#%matplotlib inline


# In[2]:


#reads csv as Pandas dataframe
baseball10 = pd.read_csv('C:\\Users\\Keenan\\Desktop\\Retrosheet\\data\\parsed\\all2010.csv', header=None)
#adds year column
baseball10["year"]=2010

baseball11 = pd.read_csv('C:\\Users\\Keenan\\Desktop\\Retrosheet\\data\\parsed\\all2011.csv', header=None)
#adds year column
baseball11["year"]=2011

baseball12 = pd.read_csv('C:\\Users\\Keenan\\Desktop\\Retrosheet\\data\\parsed\\all2012.csv', header=None)
#adds year column
baseball12["year"]=2012

baseball13 = pd.read_csv('C:\\Users\\Keenan\\Desktop\\Retrosheet\\data\\parsed\\all2013.csv', header=None)
#adds year column
baseball13["year"]=2013

baseball14 = pd.read_csv('C:\\Users\\Keenan\\Desktop\\Retrosheet\\data\\parsed\\all2014.csv', header=None)
#adds year column
baseball14["year"]=2014

#merges years
frames = [baseball10,baseball11,baseball12,baseball13,baseball14]
baseball=pd.concat(frames)

#preview of data
baseball.head()


# In[3]:


#makes copy of DF
baseballed = baseball
#columnsineed=[34,33,29,30,28,27,26]

#creates list of columns to drop, drops
dlist=[1,5,6,7,12,13,16,17,31,32]
for i in range(35,46):
    dlist.append(i)
for i in range(56,78):
    dlist.append(i)
for i in range(80,158):
    dlist.append(i)
baseballed=baseballed.drop(dlist,axis=1)

#renames columns
colnames = ["num","inning","home","outs","awscore","hoscore","batter","bathand","pitcher","pithand","pos2","pos3","pos4","pos5","pos6","pos7","pos8","pos9","run1st","run2nd","run3rd","event","leadoff","lineup","eventtype","fieldedby","hittype","bunt","foul","hitloc","errnum","errplayer1","td1","errplayer2","td2","first","last","year"]
baseballed.columns = [colnames]

#adds index and year columns
baseballed["index"] = range(len(baseballed))


# In[4]:


#builds dictionary for col numbers and names for easy access
numlist = []
for i in range(0,158):
    numlist.append(i)

for i in dlist:
    if i in numlist:
        numlist.remove(i)

names = []
for i in colnames:
    if i == 'year':
        break
    else:
        names.append(i)      

dictionary = dict(zip(names,numlist))
print(dictionary)


# In[5]:


#creates columns for numerical day and month, as well as 3 char stadium strings and a double-header dummy
#remember to convert these into dummies for regression
nlist = []
stadium = []
month = []
day = []
dhlist = []
dh2list = []

for i in baseballed['num']:
    nlist.append(i)

for i in nlist:
    st = str(i[0]+i[1]+i[2])
    stadium.append(st)
    
    mo = str(i[7]+i[8])
    month.append(mo)
    
    d = str(i[9]+i[10])
    day.append(d)
    
    if i[11]==2:
        dhlist.append(1)
        dh2list.append(1)
    elif i[11]==1:
        dhlist.append(1)
        dh2list.append(0)
    else:
        dhlist.append(0)
        dh2list.append(0)
    
baseballed['stad']=stadium
baseballed['month']=month
baseballed['day']=day
baseballed['dh']=dhlist
baseballed['dh2']=dh2list
baseballed.head()


# In[6]:


baseballed2=baseballed.drop(['num','pos2','pos3','pos4','pos5','pos6','pos7','pos8','pos9','pitcher','batter','event','hitloc'],axis=1)


# In[7]:


#creates fblist, which is the game number of each entry
fb = []
fblist = []
fbnum = 0
for i in baseballed2['first']:
    fb.append(i)
for i in range(len(fb)):
    if fb[i]=='T':
        fbnum = fbnum+1
        fblist.append(fbnum)
    else:
        fblist.append(fbnum)
print(len(fblist))

#adds gamenum column for each entry, indexed at 1
baseballed2['gamenum']=fblist


# In[8]:


#drops first and last columns which are no longer needed, returns info
baseballed2=baseballed2.drop(['first','last'],axis=1)
baseballed2.info()


# In[9]:


#replaces nulls with 0
baseballed2 = baseballed2.fillna(0)


# In[10]:


#replaces baserunner names with 1s, keeps 0s
#these fields are now basically dummy vars

firlist = []
seclist = []
thilist = []

for i in baseballed2['run1st']:
    if i==0:
        firlist.append(0)
    else:
        firlist.append(1)

for i in baseballed2['run2nd']:
    if i==0:
        seclist.append(0)
    else:
        seclist.append(1)        
        
for i in baseballed2['run3rd']:
    if i==0:
        thilist.append(0)
    else:
        thilist.append(1)
        
runlist=firlist
for i in range(len(runlist)):
    if seclist[i]==1:
        runlist[i]=1
    if thilist[i]==1:
        runlist[i]=1

#print(len(runlist))        
        
baseballed2['run1st']=firlist
baseballed2['run2nd']=seclist
baseballed2['run3rd']=thilist
baseballed2['runners']=runlist


# In[11]:


#converts leadoff to int dummy var
leadlist = []
llist = []

for i in baseballed2['leadoff']:
    llist.append(i)

for i in llist:
    if i == 'T':
        leadlist.append(1)
    else:
        leadlist.append(0)

baseballed2['leadoff']=leadlist
#print(baseballed2['leadoff'][:15])


# In[12]:


#converts bunt to binary int
blist = []
buntlist = []

for i in baseballed2['bunt']:
    blist.append(i)

for i in blist:
    if i == 'F':
        buntlist.append(0)
    else:
        buntlist.append(1)

baseballed2['bunt']=buntlist
#print(baseballed2['bunt'][:15])


# In[13]:


#converts foul to binary
flist = []
follist = []

for i in baseballed2['foul']:
    flist.append(i)

for i in flist:
    if i == 'F':
        follist.append(0)
    else:
        follist.append(1)

baseballed2['foul']=follist
#print(baseballed2['foul'][:15])


# In[14]:


#bathand and pithand
blist = []
batlist = []

for i in baseballed2['bathand']:
    blist.append(i)

for i in blist:
    if i == 'R':
        batlist.append(0)
    else:
        batlist.append(1)

baseballed2['batleft']=batlist
#print(baseballed2['batleft'][:15])

plist = []
pitlist = []

for i in baseballed2['pithand']:
    plist.append(i)

for i in plist:
    if i == 'R':
        pitlist.append(0)
    else:
        pitlist.append(1)

baseballed2['pitleft']=pitlist


# In[15]:


baseballed2=baseballed2.drop(['pithand','bathand'],axis=1)


# <pre>What do I want to find here? What are my dependent variables?
# -Did a throw error occur on the play?
# -Did a drop error occur on the play?
# 
# Do I want to consider whether a prior error occurred on the play?
# -It seems like it should be easy but also unlikely to be significant so lets circle back to it if there's time
# </pre>

# In[16]:


#errors
ethlist = []
edrlist = []
errlist = []

elist = []
for i in baseballed2['td1']:
    elist.append(i)
    
e2list = []
for i in baseballed2['td2']:
    e2list.append(i)
    
for i in elist:
    if i == 'T':
        errlist.append(1)
        ethlist.append(1)
        edrlist.append(0)
    elif i == 'D':
        errlist.append(1)
        edrlist.append(1)
        ethlist.append(0)
    else:
        errlist.append(0)
        edrlist.append(0)
        ethlist.append(0)

for i in range(len(errlist)):
    if e2list[i] =='T':
        ethlist[i] = 1
    elif e2list[i] =='D':
        edrlist[i] = 1

baseballed2['errthrow']=ethlist
baseballed2['errcatch']=ethlist
baseballed2['error']=errlist


# In[17]:


baseballed2=baseballed2.drop(['td1','td2','errnum'],axis=1)


# In[18]:


#hittype: F = flyball, L = linedrive, P = popup, G = grounder, 0 = nocontact
hlist = []
for i in baseballed2['hittype']:
    hlist.append(i)
    
grounder = []
linedrive = []
popup = []
flyball =[]

for i in hlist:
    if i == 'G':
        grounder.append(1)
        linedrive.append(0)
        popup.append(0)
        flyball.append(0)
    elif i == 'P':
        grounder.append(0)
        linedrive.append(0)
        popup.append(1)
        flyball.append(0)
    elif i == 'F':
        grounder.append(0)
        linedrive.append(0)
        popup.append(0)
        flyball.append(1)
    elif i == 'L':
        grounder.append(0)
        linedrive.append(1)
        popup.append(0)
        flyball.append(0)
    elif i == 0:
        grounder.append(0)
        linedrive.append(0)
        popup.append(0)
        flyball.append(0)

baseballed2['flyball']=flyball
baseballed2['grounder']=grounder
baseballed2['linedrive']=linedrive
baseballed2['popup']=popup


# In[19]:


baseballed2=baseballed2.drop(['hittype'],axis=1)


# In[20]:


#creates dummys for months
mlist =[]
for i in baseballed2['month']:
    mlist.append(i)

march =[]
april =[]
may =[]
june =[]
july =[]
august =[]
september =[]
october =[]    
    
def dummy(month):
    othermonths=[march,april,may,june,july,august,september,october]
    othermonths.remove(month)
    for i in othermonths:
        i.append(0)
    month.append(1)

for i in mlist:
    if i =='03':
        dummy(march)
    elif i =='04':
        dummy(april)
    elif i =='05':
        dummy(may)
    elif i =='06':
        dummy(june)
    elif i =='07':
        dummy(july)
    elif i =='08':
        dummy(august)
    elif i =='09':
        dummy(september)
    elif i =='10':
        dummy(october)
        
#for some reason it adds the first 0 for march to the april list, and presumably omits the first value in march, so...
april.pop(0)
march.insert(0,0)

baseballed2['march']=march
baseballed2['april']=april
baseballed2['may']=may
baseballed2['june']=june
baseballed2['july']=july
baseballed2['august']=august
baseballed2['september']=september
baseballed2['october']=october


# In[21]:


#overwriting baseballed with current state of baseballed2 so that I can mess around deleting rows in baseballed2
baseballed=baseballed2


# In[22]:


#recopies baseballed over to baseballed2
baseballed2=baseballed
baseballed2.info()


# In[23]:


tlist =[]
for i in baseballed2['eventtype']:
    tlist.append(i)

badindex =[]
for i in range(len(tlist)):
    if tlist[i]==3:
        badindex.append(0)
    elif tlist[i]==15:
        badindex.append(0)
    elif tlist[i]==16:
        badindex.append(0)
    else:
        badindex.append(1)
#print(len(badindex))
#print(badindex[:20])

baseballed2['keep']=badindex
baseballed2=baseballed2[baseballed2['keep']==1]


# <pre>need to remove events where the ball isnt really
# in play, consistent with thesis
# 
# event types: strikeout(3), intentional walk(15),
# hit by pitch(16)
# 
# 
# FUCKING DID IT
# </pre>

# In[24]:


baseballed2=baseballed2.drop(['keep'],axis=1)


# <pre>Dependent variables: error, errthrow, errcatch
# 
# Non-binary variables: stad, month, day, year, errplayer1, errplayer2, inning,
#                       outs, awscore, hoscore, lineup, fieldedby, gamnum
# 
# Binary variables: home, run1st, run2nd, run3rd, leadoff, bunt, foul, batleft,
#                   pitleft, flyball, grounder, linedrive, popup, runnners
# 
# Other: index, eventtype
# </pre>

# In[25]:


dummystad = pd.get_dummies(baseballed2['stad'])
bbfinal = pd.concat([baseballed2,dummystad],axis=1)


# In[26]:


bbfinal=bbfinal.drop(['index','stad'],axis=1)


# In[27]:


dummyfield = pd.get_dummies(bbfinal['fieldedby'])
bbfinal = pd.concat([bbfinal,dummyfield],axis=1)


# In[96]:


#copy without fielder==0
bbtest = bbfinal[bbfinal[0]!=1]
bbtest.info()


# # Let's get into some regressions!!!

# In[76]:


import statsmodels.api as sm
from scipy import stats
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error,r2_score


# In[77]:


#group the independents by relevant groups
collist = (list(bbfinal.columns))

stadvars = []
for i in range(collist.index('ANA'),collist.index('WAS')+1):
    stadvars.append(collist[i])
deps = ['errthrow','errcatch','error']
monthvars = ['march','april','may','june','july','august','september','october']
fieldvars = [1,2,3,4,5,6,7,8,9]
gamevars = ['hoscore','awscore','inning','home','outs','runners','lineup','bunt','foul','dh2','batleft','pitleft','flyball','grounder','linedrive','popup']
extravars = ['run1st','run2nd','run3rd','leadoff','year','dh2','gamenum']

#bear in mind I still have the ability to break down runners by base if they prove significant
#omitted leadoff for multicollinearity with lineup
#omitted gamenum because of multicollinearity with months dummys (consider adding back in for quantitative value)
#operating on the assumption that batters get weaker as you go through the lineup
#I'm only looking at whether the game is part of a DH, not whether it is actually the second game


# In[97]:


#test summary
nana = gamevars+monthvars+stadvars+fieldvars
X = bbtest[nana]
y = bbtest['error']

X2 = sm.add_constant(X)
est = sm.OLS(y, X2)
est2 = est.fit()
print(est2.summary())


# # part 2: bring in the weather data

# In[28]:


weather1 = pd.read_csv('C:\\Users\\Keenan\\Desktop\\weathers\\A.csv', header=None)
weather1.columns = weather1.iloc[0]
weather1=weather1.reindex(weather1.index.drop(0))

weather2 = pd.read_csv('C:\\Users\\Keenan\\Desktop\\weathers\\B.csv', header=None)
weather2.columns = weather2.iloc[0]
weather2=weather2.reindex(weather2.index.drop(0))

weather3 = pd.read_csv('C:\\Users\\Keenan\\Desktop\\weathers\\C.csv', header=None)
weather3.columns = weather3.iloc[0]
weather3=weather3.reindex(weather3.index.drop(0))

weather4 = pd.read_csv('C:\\Users\\Keenan\\Desktop\\weathers\\D.csv', header=None)
weather4.columns = weather4.iloc[0]
weather4=weather4.reindex(weather4.index.drop(0))

weather5 = pd.read_csv('C:\\Users\\Keenan\\Desktop\\weathers\\E.csv', header=None)
weather5.columns = weather5.iloc[0]
weather5=weather5.reindex(weather5.index.drop(0))

weathers=[weather1,weather2,weather3,weather4,weather5]
weather = pd.concat(weathers)


# In[29]:


#makes all weather 1 date strings 10 characters for later parsing
dlist=[]
newlist = []
for i in weather['DATE']:
    dlist.append(str(i))

for i in dlist:
    if len(i)==10:
        newlist.append(i)
    elif len(i)==9:
        if i[1]=='/':
            newlist.append(str('0'+i))
        elif i[4]=='/':
            newlist.append(str(i[0:3]+'0'+i[3:]))
    elif len(i)==8:
        newlist.append(str('0'+i[0:2]+'0'+i[2:]))
        
weather['DATE']=newlist


# In[30]:


gudlist = []
slist =[]
for i in weather['STATION']:
    slist.append(i)

for i in range(len(slist)):
    if slist[i]=='USW00013743':
        gudlist.append(1)
    else:
        gudlist.append(0)

weather['check']=gudlist
weather=weather[weather['check']==1]

#weather.info()


# In[31]:


weather=weather.drop(['TAVG','TOBS'],axis=1)
#weather.info()


# In[32]:


#breaks down different DATE columns into year, month, and day lists
dlist = []
for i in weather['DATE']:
    dlist.append(str(i))
    
ylist = []
mlist =[]
daylist=[]

for i in dlist:
    if i[2]=='/':
        ylist.append(int(i[6:]))
        mlist.append(int(i[:2]))
        daylist.append(int(i[3:5]))
    else:
        ylist.append(int(i[0:4]))
        mlist.append(int(i[5:7]))
        daylist.append(int(i[8:10]))

weather['day']=daylist
weather['month']=mlist
weather['year']=ylist


# In[33]:


weather=weather.drop(['check','DATE'],axis=1)


# In[36]:


weather=weather.drop(['STATION'],axis=1)


# In[41]:


bbfinal.info()


# In[45]:


#creates a list of date strings for comparison to weather
bblist = []

bylist = []
bmlist = []
bdlist = []

for i in bbfinal['year']:
    bylist.append(str(i))
for i in bbfinal['month']:
    bmlist.append(str(i))
for i in bbfinal['day']:
    bdlist.append(str(i))

for i in range(0,len(bbfinal)):
    bblist.append(str(bylist[i]+bmlist[i]+bdlist[i]))


# In[47]:


datelist = set(bblist)
print(len(datelist))
print(len(bblist))
print(bblist[:20])


# In[52]:


#creates a list of date strings for comparison to weather
welist = []

wylist = []
wmlist = []
wdlist = []

for i in weather['year']:
    wylist.append(str(i))
for i in weather['month']:
    i=str(i)
    if len(i)==1:
        wmlist.append(str('0'+i))
    elif len(i)==2:
        wmlist.append(i)
for i in weather['day']:
    i=str(i)
    if len(i)==1:
        wdlist.append(str('0'+i))
    elif len(i)==2:
        wdlist.append(i)

for i in range(0,len(weather)):
    welist.append(str(wylist[i]+wmlist[i]+wdlist[i]))
    
print(len(welist))


# In[55]:


weather['datestamp']=welist
bbfinal['datestamp']=bblist


# In[58]:


#what I want to do here is create a 760,000 long list corresponding to the 1200 index numbers in weather


# In[59]:


weatherindex = []
for i in bblist:
    weatherindex.append(welist.index(i))
    
print(len(weatherindex))


# In[81]:


#creates lists for weather vars
wind = []
for i in weather['AWND']:
    wind.append(i)
prec = []
for i in weather['PRCP']:
    prec.append(i)
tmax = []
for i in weather['TMAX']:
    tmax.append(i)
tmin = []
for i in weather['TMIN']:
    tmin.append(i)
    
windlist=[]
preclist=[]
tminlist=[]
tmaxlist=[]

for i in weatherindex:
    windlist.append(float(wind[i]))
    preclist.append(float(prec[i]))
    tmaxlist.append(float(tmax[i]))
    tminlist.append(float(tmin[i]))


# In[82]:


#creates DCbball for narrowing down to DC entries, adds weather
DCbball = bbfinal
DCbball['maxtemp']=tmaxlist
DCbball['mintemp']=tminlist
DCbball['precip']=preclist
DCbball['windspeed']=windlist


# In[83]:


#destroys all but washington events (down to 25,000)
DCbball=DCbball[DCbball['WAS']==1]


# In[84]:


DCbball=DCbball.drop(stadvars)


# In[112]:


#group the independents by relevant groups
dcollist = (list(DCbball.columns))

deps = ['errthrow','errcatch','error']
weathervars = ['maxtemp','mintemp','precip','windspeed']
monthvars = ['march','april','may','june','july','august','september','october']
fieldvars = [1,2,3,4,5,6,7,8,9]
hitvars = ['flyball','grounder','linedrive']
gamevars = ['hoscore','awscore','outs','runners','lineup','bunt','foul','batleft','pitleft','flyball','grounder','linedrive','popup']
extravars = ['inning','home','run1st','run2nd','run3rd','leadoff','year','dh','gamenum','dh2']


# In[117]:


dvars = gamevars+monthvars+fieldvars+weathervars
X = DCbball[dvars]
y = DCbball['error']

X2 = sm.add_constant(X)
est = sm.OLS(y, X2)
est2 = est.fit()
print(est2.summary())


# # let's try removing balls that aren't hit (ie 0==1)

# In[90]:


DCtest = DCbball[DCbball[0]==0]


# In[91]:


DCtest.info()


# In[111]:


dvars = dgamevars+monthvars+fieldvars+weathervars
X = DCtest[dvars]
y = DCtest['error']

X2 = sm.add_constant(X)
est = sm.OLS(y, X2)
est2 = est.fit()
print(est2.summary())

